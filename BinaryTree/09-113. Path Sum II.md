## Leetcode-113: Path Sum II

Here is the link to the problem on [Leetcode](https://leetcode.com/problems/path-sum-ii/)

---

### Problem Description

Given the `root` of a binary tree and an integer `targetSum`, return **all root-to-leaf paths** where each path’s sum equals `targetSum`.

A **leaf** is a node with no children.

Return the paths in **any order**.

---

### Constraints

- The number of nodes in the tree is in the range `[0, 5000]`.
- `-1000 <= Node.val <= 1000`
- `-1000 <= targetSum <= 1000`

---

### Example 1:

- **Input**:  
  `root = [5,4,8,11,null,13,4,7,2,null,null,5,1]`,  
  `targetSum = 22`

- **Output**:  
  `[[5,4,11,2],[5,8,4,5]]`

- **Explanation**:  
  The two paths that sum up to 22 are:
  - 5 → 4 → 11 → 2
  - 5 → 8 → 4 → 5

---

### Example 2:

- **Input**: `root = [1,2,3]`, `targetSum = 5`
- **Output**: `[]`

---

### Solution

Here is a Java solution for the problem:

```java
class Solution{
     public List<List<Integer>> pathSum(TreeNode root,int target){
        if(root==null) return ans;
        answer(root, target);
        return ans;
    }
    List<Integer> subAns = new ArrayList<>();
    List<List<Integer>> ans = new ArrayList<>();

    public void answer(TreeNode root, int target){
        if(root == null) return;

        subAns.add(root.val);

        if(root.left == null && root.right == null && target == root.val) {
            ans.add(new ArrayList<>(subAns));
        }

        answer(root.left, target - root.val);
        answer(root.right, target - root.val);

        subAns.remove(subAns.size() - 1); // backtrack
    }
}
